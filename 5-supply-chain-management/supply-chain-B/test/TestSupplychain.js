// This script is designed to test the solidity smart contract - Suppychain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var Supplychain = artifacts.require('Supplychain')

contract('Supplychain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    const brandy = accounts[0]  // smart contract owner
    const jlin = accounts[1]    // seller
    const joe = accounts[2]     // buyer
    const elena = accounts[3]   // seller
    const pk = accounts[4]      // buyer
    const emptyAddress = '0x0000000000000000000000000000000000000000'

    // Declare few more constants for item names and prices
    var sku
    const nameA = "bagel"                  // item A is bagel
    const nameB = "pizza"                  // item B is pizza
    const priceA = web3.toWei(1, "ether")  // price A is 1 ether
    const priceB = web3.toWei(2, "ether")  // price B is 2 ether

    // 1st Test
    it("Testing smart contract function addItem() that allows a seller to add an item to a blockchain inventory", async() => {
        const supplyChain = await Supplychain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event ForSale() for a sku
        var event = supplyChain.ForSale()
        await event.watch((err, res) => {
            sku = res.args.sku.toString(10)
            eventEmitted = true
        })

        // Add an item to the inventory stored in blockchain by calling function addItem()
        await supplyChain.addItem(nameA, priceA, {from: jlin})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const result = await supplyChain.fetchItem.call(sku)

        // Verify the result set: name, sku, price, state, seller, buyer
        assert.equal(result[0], nameA, 'Error: The name of the previously added item is not matching the expected value')
        assert.equal(result[2].toString(10), priceA, 'Error: The price of the previously added item is not matching the expected value')
        assert.equal(result[3].toString(10), 0, 'Error: The state of the previously added item should be "For Sale"')
        assert.equal(result[4], jlin, 'Error: The account address of the previously added item should be a seller e.g. jlin | elena')
        assert.equal(result[5], emptyAddress, 'Error: The buyer address should be 0 when a new item is added')
        assert.equal(eventEmitted, true, 'Error: When a new item is added, event ForSale() should be emitted')
    })

    // 2nd Test
    it("Testing smart contract function buyItem() that allows a buyer to purchase an item from a blockchain inventory", async() => {
        const supplyChain = await Supplychain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false

        // Watch the emitted event Sold() for a sku
        var event = supplyChain.Sold()
        await event.watch((err, res) => {
            sku = res.args.sku.toString(10)
            eventEmitted = true
        })

        // Declare and assign an amount the buyer is willing to pay
        const buyAmount = web3.toWei(2, "ether")

        // Retrieve the wallet balances of seller-jlin and buyer-joe before calling the function buyItem()
        var jlinBalanceBefore = await web3.eth.getBalance(jlin).toNumber()
        var joeBalanceBefore = await web3.eth.getBalance(joe).toNumber()
        
        // Buy an item from the inventory
        await supplyChain.buyItem(sku, {from: joe, value: buyAmount})

        // Retrive the wallet balances of seller-jlin and buyer-joe after calling the function buyItem()
        var jlinBalanceAfter = await web3.eth.getBalance(jlin).toNumber()
        var joeBalanceAfter = await web3.eth.getBalance(joe).toNumber()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const result = await supplyChain.fetchItem.call(sku)

        // Verify the result set: name, sku, price, state, seller, buyer
        assert.equal(result[3].toString(10), 1, 'Error: The state of the just bought item should be "Sold"')
        assert.equal(result[5], joe, 'Error: The account address of the just bought item should be a buyer e.g. joe | pk')
        assert.equal(eventEmitted, true, 'Error: When a item is bought, event Sold() should be emitted')
        assert.equal(jlinBalanceAfter, jlinBalanceBefore + parseInt(priceA, 10), "Error: seller-jlin's account balance should be increased by the price of the item bought")
        assert.isBelow(joeBalanceAfter, joeBalanceBefore - priceA, "Error: buyer-joe's account balance should be reduced by the price of the item bought + any gas costs")
    })

    // 3rd Test
    it("Testing smart contract function shipItem() that allows a seller to mark an item as shipped in a blockchain inventory", async() => {
        const supplyChain = await Supplychain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event Shipped() for a sku
        var event = supplyChain.Shipped()
        await event.watch((err, res) => {
            sku = res.args.sku.toString(10)
            eventEmitted = true
        })

        // Mark an item as shipped
        await supplyChain.shipItem(sku, {from: jlin})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const result = await supplyChain.fetchItem.call(sku)

        // Verify the result set: name, sku, price, state, seller, buyer
        assert.equal(result[3].toString(10), 2, 'Error: The state of the just shipped item should be "Shipped"')
        assert.equal(eventEmitted, true, 'Error: When a item is shipped, event Shipped() should be emitted')
    })

    // 4th Test
    it("Testing smart contract function receiveItem() that allow a buyer to mark an item as received in a blockchain inventory", async() => {
        const supplyChain = await Supplychain.deployed()

        // Declare and Initialize a variable for event
        var eventEmitted = false

        // Watch the emitted event Received() for a sku
        var event = supplyChain.Received()
        await event.watch((err, res) => {
            sku = res.args.sku.toString(10)
            eventEmitted = true
        })

        // Mark an item as received
        await supplyChain.receiveItem(sku, {from: joe})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const result = await supplyChain.fetchItem.call(sku)

        // Verify the result set: name, sku, price, state, seller, buyer
        assert.equal(result[3].toString(10), 3, 'Error: The state of the just received item should be "Received"')
        assert.equal(eventEmitted, true, 'Error: When a item is received, event Received() should be emitted')

    })

    // 5th Test
    it("Testing smart contract function fetchItem() that allows anyone to fetch item details from a blockchain inventory", async() => {
        const supplyChain = await Supplychain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event ForSale() for a sku
        var event = supplyChain.ForSale()
        await event.watch((err, res) => {
            sku = res.args.sku.toString(10)
            eventEmitted = true
        })

        // Add an item to the inventory stored in blockchain by calling function addItem()
        await supplyChain.addItem(nameB, priceB, {from: elena})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const result = await supplyChain.fetchItem.call(sku)

        // Verify the result set: name, sku, price, state, seller, buyer
        assert.equal(result[0], nameB, 'Error: The name of the previously added item is not matching the expected value')
        assert.equal(result[2].toString(10), priceB, 'Error: The price of the previously added item is not matching the expected value')
        assert.equal(result[3].toString(10), 0, 'Error: The state of the previously added item should be "For Sale"')
        assert.equal(result[4], elena, 'Error: The account address of the previously added item should be a seller e.g. jlin | elena')
        assert.equal(result[5], emptyAddress, 'Error: The buyer address should be 0 when a new item is added')
        assert.equal(eventEmitted, true, 'Error: When a new item is added, event ForSale() should be emitted')
    })

});
